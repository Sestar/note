# 开闭原则

## 概念

&emsp;&emsp;一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。模块应尽量在不修改原（是“原”，指原来的代码）代码的情况下进行扩展。

## 模拟场景

&emsp;&emsp;在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。

## 注意事项

&emsp;&emsp;- 通过接口或者抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法  
&emsp;&emsp;- 参数类型、引用对象尽量使用接口或者抽象类，而不是实现类  
&emsp;&emsp;- 抽象层尽量保持稳定，一旦确定即不允许修改  

## 重要性

&emsp;&emsp;-开闭原则对测试的影响  
&emsp;&emsp;&emsp;&emsp;开闭原则可是保持原有的测试代码仍然能够正常运行，我们只需要对扩展的代码进行测试就可以了。

&emsp;&emsp;-开闭原则可以提高复用性  
&emsp;&emsp;&emsp;&emsp;在面向对象的设计中，所有的逻辑都是从原子逻辑组合而来的，而不是在一个类中独立实现一个业务逻辑。只有这样代码才可以复用，粒度越小，被复用的可能性就越大。

&emsp;&emsp;-开闭原则可以提高可维护性  

&emsp;&emsp;-面向对象开发的要求

## 应用实例

&emsp;&emsp;通过内存缓存解决了每次从网络加载图片的问题，但是，Android应用的内存很有限，且具有易失性，即当app重新启动之后，原来已经加载过的图片将会丢失，这样重启之后就又需要重新下载。这又会导致加载缓慢、耗费用户流量的问题。所以我们应该引入SD卡缓存，这样下载过的图片就会缓存到本地，即使重启应用也不需要重新下载了。需要ImageLoader类(图片加载工具类)加入我们的DiskCache。再修改下载和显示逻辑，加入判断SD卡缓存里有没有缓存过要显示的图片，有缓存则直接取缓存显示，避免再下载。现在我们只需在使用ImageLoader时，调用一下setDiskCahe(Context context)方法就能使用SD卡缓存图片，这是不是很方便。  

&emsp;&emsp;但是我们在添加一个DiskCache缓存时修改了许多ImageLoader代码，如果我们需要更多缓存方式或更多缓存策略，比如只使用内存缓存，或内存缓存和SD卡缓存同时使用等等需求，每次加新的缓存方法时都要修改原来的代码，这样很可能会引入Bug，而且会使原来的代码逻辑变得越来越复杂，按照上面这样的方法实现，用户也不能自定义缓存实现。  

&emsp;&emsp;软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是对于修改是封闭的，这就是开放-关闭原则。也就是说，当软件需要变化时，我们应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。如何实现ImageLoader类需要的cache能扩展呢？我们可以定义一个ImageCache接口，而我们的ImageLoader类只需操作这个ImageCache类就可以了.这就实现了用抽象类或接口来实现原功能的扩展。  
&nbsp;&nbsp;

<div align=center>

![开闭原则-提取功能类](/note/_v_images/java/设计原则/ocp1.jpg)

</div>
&nbsp;&nbsp;
&emsp;&emsp;通过setImageCache（ImageCache cache）方法注入不同的缓存实现，这样不仅能够使ImageLoader更简单、健壮，也使得ImageLoader的可扩展性、灵活性更高。MemoryCache、DiskCache、DoubleCache缓存图片的具体实现完全不一样，但是，它们的一个特点是都实现了ImageCache接口。当用户需要自定义实现缓存策略时，只需要新建一个实现ImageCache接口的类，然后构造该类的对象，并且通setImageCache（ImageCache cache）注入到ImageLoader中，这样ImageLoader就实现了变化万千的缓存策略，而扩展这些缓存策略并不会导致ImageLoader类的修改。

&emsp;&emsp;开闭原则指导我们，当软件需要变化时，应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。这里的“应该尽量”4个字说明OCP原则并不是说绝对不可以修改原始类的，当我们嗅到原来的代码“腐化气味”时，应该尽早地重构，以使得代码恢复到正常的“进化”轨道，而不是通过继承等方式添加新的实现，这会导致类型的膨胀以及历史遗留代码的冗余。当然我们在开发过程中也没有那么理想化的状况，完全地不用修改原来的代码，因此，在开发过程中需要自己结合具体情况进行考量，是通过修改旧代码还是通过继承使得软件系统更稳定、更灵活，在保证去除“代码腐化”的同时，也保证原有模块的正确性。

<div align=right>

[实例样本](https://blog.csdn.net/jo__yang/article/details/52027218)
</div>
